\documentclass[12pt,a4paper]{article}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage[tmargin=2cm, bmargin=2cm, lmargin=2cm, rmargin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{indentfirst}
\usepackage[pdftex]{hyperref}
\usepackage{enumerate}
\usepackage{bbm,amsthm,amssymb,amstext,amsmath}
\usepackage{verbatim}

\author{
    André Meneghelli Vale - 4898948\\
    \texttt{andredalton@gmail.com}
    \and
    Marcello Souza de Oliveira - 6432692\\
    \texttt{mcellor210@gmail.com}
}

\title{Relatório: IronMan}

\begin{document}
\maketitle

\section{Descrição do problema, Abordagem, Algorítmo da punição}

\subsection{Descrição do problema}

   O presente Exercício Programa tem por finalidade simular o \emph{Campeonato Mundial 
de \'Iron Man\'}. Neste, o triatleta deve ser capaz de percorrer 3.8 Km de natação,
seguido de 180 Km de ciclismo e por fim 42 Km de corrida. Sendo que a estrada do ciclismo possui
trechos planos, descidas e de subidas. Esses competidores são usualmente
divididos entre homens profissionais (hp), mulheres profissionais (mp), homens
amadores (ha) e mulheres amadoras (ma).
   Este simulador, parte da solução concorrente em \verb+linguagem \'C\'+ e faz uso da
biblioteca \verb+\'pthread.h\'+, para alocação e gerênciamento de \verb+POSIX threads+ para
Linux. A idéia básica é criar hp + mp + ha + ma threads atletas e uma thread que
gerencie a classificação destes e limitar o paralelismo desses processos
pelas seguintes condições:

\begin{itemize}
\item Entre a fase de natação e ciclismo, existe um trajeto de transição com um
portal na entrada e um portal na saída, nos quais não se pode passar em paralelo
(fila indiana) e denominado transição T1;
\item Entre a fase de ciclismo e corrida, existe outro trajeto de transição
similar ao primeiro e denominado T2;
\item Na fase de ciclismo, não pode haver mais que 3 atletas lado a lado (mesmo
tempo e posição - trajeto de 3 faixas);
\item Cada fase possui um intervalo de tempo ou velocidade para conclusão por
unidade de 100 m na natação e 1 Km nos demais.
\item A cada 30 min ou 1 min (debug) de corrida o programa deve fornecer
dados referentes a posição de cada participante e por fim a classificação
final com os tempos destes atletas.
\end{itemize}

\subsection{Abordagem}

\subsection{Algorítimo da punição}

\pagebreak
\section{Compilação, Sistema e Implementação}
O exercício programa entregue, bem como quaisquer testes, foram realizados em sistemas baseados em Debian com diversos tipos de arquiteruras diferentes e em um servidor instalado com SUSE Linux Enterprise Server 11.

\subsection{Compilação}
Junto com o código, há um \verb+Makefile+. A compilação é feita usando o 
comando \verb+make+. Por praticidade foram criandas duas targets extras \verb+all+ e \verb+clear+ que compilam todos os executáveis e limpa todo o conteúdo gerado na compilação automaticamente. Também é possível gerar um relatório automático que atualiza este relatório com os valores calculados para o computador do leitor. Para tanto basta executar o \verb+./relatorio.sh+.

\subsection{Como utilizar}
Para rodar o programa, após tê-lo compilado, executar:
\begin{quote}
\begin{verbatim}
./ep1 -debug [entrada]
\end{verbatim}
\end{quote}

Onde:

\verb+-debug+ significa que o programa irá rodar em modo de depuração e imprimirá uma linha com a posição de todos os atletas a cada minuto. Caso contrário irá imprimir os três primeiros colocados de cada categoria a cada 30 minutos.

\verb+[entrada]+ um arquivo que contém os dados sobre a quantidade de atletas e a condição do terreno na prova de ciclismo.

OBS: Os arquivos estão localizados no diretório \verb+entradas/+. O formato do arquivo de entrada deve seguir a descrição do enunciado do problema em \verb+ep1.pdf+, não foram tratados erros de formatação do arquivo de entrada.

\subsection{Códigos}
O código foi fragmentado em 3 arquivos .c principais e mais dois arquivos de cabeçalho:

\begin{itemize}
\item \verb+ep1.c+: Contém as duas funções que definem a classificação e os atletas e mais duas funções principais, as quais são escolhidas em tempo de compilação:
\begin{itemize}
\item \verb+ironMain+: É a função principal para a versão \textit{paralela} e para a versão \textit{concorrente} do problema.
\item \verb+gutsMain+: É a função principal para a versão \textit{iterativa} do problema.
\end{itemize}
\item \verb+tempos.c+ e \verb+tempos.h+: Contém a geração aleatória dos tempos de cada atleta, respeitando os limites estipulados no enunciado do problema.
\item \verb+defines.c+ e \verb+defines.h+:  Contém a maioria dos defines, as estruturas de dados usadas no problema e ainda uma função principal para realizar uma simulação interativa do algorítimo da punição. A utilização deste executável será tratada adiante.
\end{itemize}

\subsection{Executáveis}

Foram desenvolvidos 3 algorítmos diferentes para solucionar o problema e cada um destes algorítimos foi implementado com precisão de segundos e milisegundos além de mais dois executáveis extras para auxilio do entendimento do problema. A seguir segue uma breve descrilção de cada um deles: 

\begin{itemize}
\item \verb+ep1+: Programa principal. Roda a solução \textit{concorrente} com precisão de 1s.
\item \verb+ep1-mili+: Mesmo algoritmo do \verb+ep1+ porém rodando com precisão de 1ms. Essa precisão diminui consideravelmente o número de colisões.
\item \verb+pep1+: Roda a solução totalmente em paralelo com precisão de 1s. Portanto não é capaz de calcular as punições. Foi a primeira solução desenvolvida e foi mantida para ser usada como ferramenta de análise dos efeitos da concorrência.
\item \verb+pep1-mili+: Mesmo algoritmo de \verb+pep1+ porém com precisão de 1ms.
\item \verb+gep1+: Após o desenvolvimento da função de punição tratar o problema de modo iterativo se tornou possível. Este executável tem o objetivo de testar os efeitos da execução do programa em apenas um núcleo de processamento. Tem precisão de 1s.
\item \verb+gep1-mili+: Exatamente igual a \verb+gep1+, porém com precisão de 1ms.
\item \verb+ep1-sleep+: Exatamente igual a \verb+ep1+, no entanto pausa a saída do programa em 1 décimo de segundo após a ultima impressão de resultados.
\item \verb+simula+: Executável que simula o \textbf{algoritimo da punição}. Este programa pode receber \verb+-h+ para imprimir uma ajuda ou então dois números naturais que representam a quantidade de faixas disponível e a quantidade de atletas que esta participando do evento.
\end{itemize}

\pagebreak
\section{Testes}
Aqui serão expostos os arquivos de teste utilizados e os resultados finais.
\subsection{Arquivos de entrada}

\begin{itemize}
\item \verb+arquivo1.txt+: \\*
\texttt{5 5 20 20 P 50 S 10 D 20 P 100}
\item \verb+arquivo2.txt+: \\*
\texttt{20 15 100 65 P 10 S 10 D 10 P 20 S 6 D 10 P 20 S 10 D 10 P 30 S 10 D 10 P 24}
\item \verb+arquivo3.txt+: \\*
\texttt{500 500 500 500 P 50 S 10 D 20 P 100}
\item \verb+arquivo4.txt+: \\*
\texttt{5000 5000 5000 5000 P 10 S 10 D 10 P 20 S 6 D 10 P 20 S 10 D 10 P 30 S 10 D 10 P 24}
\item \verb+arquivo5.txt+: Este arquivo teve muitos problemas e não foi executado na maioria dos testes. \\*
\texttt{25000 25000 25000 25000 P 10 S 10 D 10 P 20 S 6 D 10 P 20 S 10 D 10 P 30 S 10 D 10 P 24}
\end{itemize}

\subsection{Saida \'arquivo1.txt\'}


A distância entre $Ax$ e $b$ é justamente a norma do vetor $b-Ax$ que calculamos com o programa.
Seu valor é aproximadamente $1.82216$.

\pagebreak
\section{Exemplo 2}
Nesta seção, algumas considerações e respostas sobre o segundo exemplo.
\subsection{Formulação do problema}
Dado o polinômio cúbico $c_0 + c_1s + c_2s^2 + c_3s^3$, obtemos o sistema:

\[
\left[
\begin{array}{cccc}
    1 & s_1 & s_{1}^{2} & s_{1}^{3} \\
      & ... \\
    1 & s_{11} & s_{11}^{2} & s_{11}^{3} \\
\end{array}
\right]
\left[
\begin{array}{c}
    c_0 \\
    c_1 \\
    c_2 \\
    c_3 \\
\end{array}
\right]
=
\left[
\begin{array}{c}
    75.995 \\
    ... \\
    281.422 \\
\end{array}
\right]
\]

Onde $s_i$ é $(t_i-1950)/50$. Substituindo, temos aproximadamente:

\[
\left[
\begin{array}{cccc}
    1.00 & -1.00 & 1.00 & -1.00 \\
    1.00 & -0.80 & 0.64 & -0.51 \\
    1.00 & -0.60 & 0.36 & -0.22 \\
    1.00 & -0.40 & 0.16 & -0.06 \\
    1.00 & -0.20 & 0.04 & -0.01 \\
    1.00 & 0.00 & 0.00 & 0.00 \\
    1.00 & 0.20 & 0.04 & 0.01 \\
    1.00 & 0.40 & 0.16 & 0.06 \\
    1.00 & 0.60 & 0.36 & 0.22 \\
    1.00 & 0.80 & 0.64 & 0.51 \\
    1.00 & 1.00 & 1.00 & 1.00 \\
\end{array}
\right]
\left[
\begin{array}{c}
    c_0 \\
    c_1 \\
    c_2 \\
    c_3 \\
\end{array}
\right]
=
\left[
\begin{array}{c}
    75.995 \\
    91.972 \\
    105.711 \\
    123.203 \\
    131.669 \\
    150.697 \\
    279.323 \\
    203.212 \\
    226.505 \\
    249.633 \\
    281.422 \\
\end{array}
\right]
\]

\subsection{Resultado}
Resolvendo o sistema, obtemos o vetor aproximado:
\[
\left[
\begin{array}{c}
    155.90427 \\
    100.36592 \\
    23.72614 \\
    1.26294 \\
\end{array}
\right]
\]

Donde, fazendo as devidas substituições, obtemos o valor aproximado $312.691$ 
para o ano de $2010$. O gráfico abaixo dá uma ideia melhor sobre o ajuste da 
função aos pontos.

\begin{figure}[H]\centering
    \includegraphics[scale=0.5]{polinomio.jpg}
    \caption{Ajuste dos pontos ao polinômio.}
\end{figure}

\section{Exemplo 3}
Nesta seção, algumas considerações e respostas sobre o terceiro exemplo.
\subsection{Formulação do problema}
Dado $z = 0$ e $f = 1$, obtemos o polinômio de duas variáveis $ax^2 + bxy + cy^2 + dx + ey$ que resulta no sistema:

\[
\left[
\begin{array}{ccccc}
    x_{1}^2 & x_{1}y_{1} & y_{1}^{2} & x_{1} & y_{1} \\
     & & ... \\
    x_{10}^2 & x_{10}y_{10} & y_{10}^{2} & x_{10} & y_{10} \\
\end{array}
\right]
\left[
\begin{array}{c}
    a \\
    b \\
    c \\
    d \\
    e \\
\end{array}
\right]
=
\left[
\begin{array}{c}
    -1 \\
    ... \\
    -1 \\
\end{array}
\right]
\]

Substituindo, temos aproximadamente:

\[
\left[
\begin{array}{ccccc}
    1.04 & 0.40 & 0.15 & 1.02 & 0.39 \\
    0.90 & 0.30 & 0.10 & 0.95 & 0.32 \\
    0.76 & 0.23 & 0.07 & 0.87 & 0.27 \\
    0.59 & 0.17 & 0.05 & 0.77 & 0.22 \\
    0.45 & 0.12 & 0.03 & 0.67 & 0.18 \\
    0.31 & 0.08 & 0.02 & 0.56 & 0.15 \\
    0.19 & 0.06 & 0.02 & 0.44 & 0.13 \\
    0.09 & 0.04 & 0.01 & 0.30 & 0.12 \\
    0.03 & 0.02 & 0.02 & 0.16 & 0.13 \\
    0.00 & 0.00 & 0.02 & 0.01 & 0.15 \\
\end{array}
\right]
\left[
\begin{array}{c}
    a \\
    b \\
    c \\
    d \\
    e \\
\end{array}
\right]
=
\left[
\begin{array}{c}
    -1 \\
    -1 \\
    -1 \\
    -1 \\
    -1 \\
    -1 \\
    -1 \\
    -1 \\
    -1 \\
    -1 \\
\end{array}
\right]
\]

\subsection{Resultado}
Resolvendo o sistema, obtemos o vetor aproximado:
\[
\left[
\begin{array}{c}
    2.25379 \\
    0.00632 \\
    5.52218 \\
    -1.28981 \\
    -7.37735 \\
\end{array}
\right]
\]

O erro obtido foi de aproximadamente $0.02778$. Isso significa que o ajuste 
deverá ser razoavelmente bom. A imagem evidencia a qualidade do ajuste.

\begin{figure}[ht]\centering
    \includegraphics[scale=0.5]{elipse.jpg}
    \caption{Ajuste da elipse gerada a partir do MMQ}
\end{figure}

\begin{thebibliography}{9999}
    \bibitem[GSM]{GSM}Wikipedia, \textsl{Gram-Schmidt process},\\
        \mbox{}\hfill\texttt{http://en.wikipedia.org/wiki/Gram-Schmidt}
\end{thebibliography}
\end{document}
